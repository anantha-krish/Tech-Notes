{"_id":"note:Ki4ydUJe6","title":"JS Basics","content":"## Introducing Script in HTML\n\n- Inline Way\n```html\n    <script>\n        console.log('Hello World !')\n    </script>\n```\n\n- Using External File\n\nstep 1: Create a new file named  \"script.js\"\n```js\nconsole.log('Hello World !')\n```\n\nstep 2: Import the file in HTML (Preferably at end )\n```html\n<script src=\"script.js\"></script>\n```\n\n\n## DataTypes & Variables\n\nJavaScript has dynamic typing.\ni.e dataTypes are automatically assigned.\n\nThere are basically 5 datatypes:\n\n- Number: Floating point numbers\n- String\n- Boolean\n- Undefined: datatype is not assigned to variable\n- Null\n\n```js\n//Number\nvar age=28;\nconsole.log(age);\n\n//String\nvar firstName ='John';\nconsole.log(firstName);\n\n//Boolean\nvar fullAge = false;\nconsole.log(fullAge);\n\n//undefined\nvar teacher;\nconsole.log(teacher);\n\n```\n\n## Type Coercion & Variable Mutation\n\n - Type Coercion -> The number & boolean is converted to string automatically\n \n - Variable Mutation -> contents/datatyes of variable can be changed anytime\n\n```js\n /* \nType Coercion & Variable Mutation \n************/\n\nvar age=28;\nvar firstName ='John';\n\n// Type Coercion <- the number & boolean is converted to string\nconsole.log( firstName + ' '+ age);\n\n\nvar job, isMarried;\njob='Teacher';\nisMarried = false;\n\nconsole.log(firstName +' is a '+ age +' years old ' + job +\n'. Is he Married ?'+isMarried\n)\n\n//Variable Mutation <- contents/datatyes can be changed in JS\nage ='twenty eight';\njob = 'driver';\n\n// alert window Example\nalert( firstName +' is a '+ age +' years old ' + job +\n'. Is he Married ?'+isMarried )\n\n//prompt window example\nvar lastName = prompt('What is his Last Name ?');\nconsole.log( firstName +' '+ lastName);\n\n//typeof operator\n\nconsole.log(typeof age)  //number\nconsole.log(typeof isMarried)  //boolean\n```\n\n## Truthy, Falsy values and equality operators\n\n * falsy values : undefined , null , 0, '' , NaN\n * truthy values : NOT falsy values\n *  '==' does type coercion on operands\n *  '===' is better to use in javascript as its more strict\n\n```js\n\n/******\n * Truthy,Falsy values and equality operators\n * \n * falsy values : undefined , null, 0, '',NaN\n * truthy values : NOT falsy values\n */\n\nvar height =23;\nif( height || height === 0 )\nconsole.log('Variable is defined')\n\nelse\nconsole.log ('variable is not defined')\n\n//equality operator\nif( height =='23')\nconsole.log('The == operator does type coercion, operands can be different type')\n\nif( height === 23)\nconsole.log('The === operator is stricter operands should have same type')\n\n```\n\n## Function Statements & Expressions\n\n- Statements are those which doesnot return any immediate value\n Ex: If else, Switch , variable declaration etc.\n \n- Expression are those which return an immediate value.\nEx: call(), x > 2 , x === y , typeof 2 etc..\n\n\n```js\n// function statement\nfunction sum (a,b)\n{\n  return a + b;\n}\n\n// function expression \nvar sum =  function(a,b)\n{\nreturn a + b ;\n}\n```\n## Arrays\n- index starts with 0\n-  array.length -> will give size of array\n-  array.push(element) ->  inserts element at the end of array\n-  array.unshift(element) -> inserts element at the starting of array\n-  array.pop()-> deletion from the end\n-  array.shift()-> deletion from the start\n-  array.indexOf(element)-> will return the index if found else will return -1 (not found);\n\n```js\n// Initialize new array\nvar names = ['John', 'Mark', 'Jane'];\nvar years = new Array(1990, 1969, 1948);\n\nconsole.log(names[2]);\nconsole.log(names.length);\n\n// Mutate array data\nnames[1] = 'Ben';\nnames[names.length] = 'Mary';\nconsole.log(names);\n\n// Different data types\nvar john = ['John', 'Smith', 1990, 'designer', false];\n\njohn.push('blue');\njohn.unshift('Mr.');\nconsole.log(john);\n\njohn.pop();\njohn.pop();\njohn.shift();\nconsole.log(john);\n\nconsole.log(john.indexOf(23));\n\nvar isDesigner = john.indexOf('designer') === -1 ? 'John is NOT a designer' : 'John IS a designer';\nconsole.log(isDesigner);\n```\n\n## Objects & properties\n\nin objects we do key-value pairing. To access a value, you have two ways:\n\n- Dot operator : object.firstName\n- Indexing : object['firstName']    <- Important key should be passed as string.\n\n```js\n// Object literal\nvar john = {\n    firstName: 'John',\n    lastName: 'Smith',\n    birthYear: 1990,\n    family: ['Jane', 'Mark', 'Bob', 'Emily'],\n    job: 'teacher',\n    isMarried: false\n};\n\nconsole.log(john.firstName);\nconsole.log(john['lastName']);\nvar x = 'birthYear';\nconsole.log(john[x]);\n\njohn.job = 'designer';\njohn['isMarried'] = true;\nconsole.log(john);\n\n// new Object syntax\nvar jane = new Object();\njane.firstName = 'Jane';\njane.birthYear = 1969;\njane['lastName'] = 'Smith';\nconsole.log(jane);\n```\n## Objects & Methods\n\n\nA function is a piece of code that is called by name. It can be passed data to operate on (i.e. the parameters) and can optionally return data (the return value). All data that is passed to a function is explicitly passed.\n\nA method is a piece of code that is called by a name that is associated with an object. i.e implicitily passed with object & scope is limited to data inside the class.\n\n```js\nvar john = {\n    firstName: 'John',\n    lastName: 'Smith',\n    birthYear: 1992,\n    family: ['Jane', 'Mark', 'Bob', 'Emily'],\n    job: 'teacher',\n    isMarried: false,\n    //function expression\n    calcAge: function() {\n        this.age = 2018 - this.birthYear;\n    }\n};\n\njohn.calcAge();\nconsole.log(john);\n\n```\n## Looping & iteration\n\n```js\nvar john = ['John', 'Smith', 1990, 'designer', false, 'blue'];\n\nfor (var i = 0; i < john.length; i++) {\n    console.log(john[i]);\n}\n\n// Looping backwards\nfor (var i = john.length - 1; i >= 0; i--) {\n    console.log(john[i]);\n}\n\n```\n\n\n## How JS works behind the scenes\n\nobjects defined directly are stored in global context or also known as window objects\n\nfunctions executions are provided different execution contexts.\n\n\n### Hoisting\n- functions are already available after hoisting\n- variables or function expressions are undefined after hoist\n\n Example 1 : functions -> statement vs expressions\n```js\nconsole.log(age(1995)) *//<- works\n\n// functions are already available after hoisting\n function age(year)\n{\n    return 2020 - year\n}\n\nconsole.log(retirement (2020)) // error\n\n// variables or function expressions are undefined after hoist\n// only available during execution time\nvar retirement = function (year)\n{\n    return 65 - (2020 -year)\n}\nconsole.log(retirement (1990)) // <-works\n```\n\n\n- Example 2: Variables\n```js\nconsole.log(age) //undefined\nvar age = 23\nfunction test ()\n{  //Note: the varaible name of global & local is same \n    console.log(age) // in current scope its undefined\n    var age = 34\n    console.log(age) // 34\n}\ntest()\nconsole.log(age) //24\n```\n\n### Scoping\nInner functions can access the variables in outer functions\n```js\n var a = 'Hello!';\nfirst();\nfunction first() {\n    var b = 'Hi!';\n    second();\n\n    function second() {\n        var c = 'Hey!';\n        console.log(a + b + c); // can access b & c\n    }\n} \n```\n\n### Difference bw execution stack & scope chain\n``Scope chain ->`` Order in which functions are written lexically\n\n``Execution stack->`` Order in which function is called\n```js\nvar a = 'Hello!';\nfirst();\n\nfunction first() {\n    var b = 'Hi!';\n    second();\n\n    function second() {\n        var c = 'Hey!';\n        third()\n    }\n}\n\nfunction third() {\n    var d = 'John';\n    console.log(a +  d); // b & c cannot be accessed.\n}\n```\n\n\nThis pointer pending...\n\n\ntype conversion\n\nparseInt ,parseFloat","tags":[],"folderPathname":"/","data":{},"createdAt":"2020-10-01T04:40:53.611Z","updatedAt":"2020-10-11T06:38:14.742Z","trashed":false,"_rev":"gDnZIU_qq"}