{"_id":"note:4z8dvp0Ag","title":"Async Reference API calls","content":"\n## Simple Async Example\n```js\n\t\tconst second = () => {\n            setTimeout(() => {\n                console.log('Async Hey there');\n            }, 2000);\n        }\n\n        const first = () => {\n            console.log('Hey there');\n            second();\n            console.log('The end');\n        }\n\n        first();\n\nOutput\nHey there\nThe end\nAsync Hey there\n```\n\n\n## Promise Hell (Triangluar Wait)\n\nas there will be more promises ,\ncode maintainence will be difficult\n```js\n        function getRecipe() {\n            setTimeout(() => {\n                const recipeID = [523, 883, 432, 974];\n                console.log(recipeID);\n\n                setTimeout(id => {\n                    const recipe = {title: 'Fresh tomato pasta', publisher: 'Jonas'};\n                    console.log(`${id}: ${recipe.title}`);\n\n                    setTimeout(publisher => {\n                        const recipe2 = {title: 'Italian Pizza', publisher: 'Jonas'};\n                        console.log(recipe);\n                    }, 1500, recipe.publisher);\n\n                }, 1500, recipeID[2]);\n\n            }, 1500);\n        }\n        getRecipe();\n\n\n```\n\n## Promise Approach (Solution to Promise Hell)\n\n```js\n\n//Define seperate function that returns  promises\nconst getIDs = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                resolve([523, 883, 432, 974]);\n            }, 1500);\n        });\n\n\nconst getRecipe = recID => {\n    return new Promise((resolve, reject) => {\n        setTimeout(ID => {\n            const recipe = {title: 'Fresh tomato pasta', publisher: 'Jonas'};\n            resolve(`${ID}: ${recipe.title}`);\n        }, 1500, recID);\n    });\n};\n\nconst getRelated = publisher => {\n    return new Promise((resolve, reject) => {\n        setTimeout(pub => {\n            const recipe = {title: 'Italian Pizza', publisher: 'Jonas'};\n            resolve(`${pub}: ${recipe.title}`);\n        }, 1500, publisher);\n    });\n};\n\n// sequentially apply then instead of nesting\n\ngetIDs\n.then(IDs => {\n    //path to resolved promises\n    console.log(IDs);\n    return getRecipe(IDs[2]);\n})\n.then(recipe => {\n    console.log(recipe);\n    return getRelated('Jonas Schmedtmann');\n})\n.then(recipe => {\n    console.log(recipe);\n})\n.catch(error => {\n    //path to rejected promises\n    console.log('Error!!');\n});\n```\n\n\n## Soln in async await approach (best Approach)\n\nNo need of sequential .then statements...\n```js\nasync function getRecipesAW() {\n    const IDs = await getIDs;\n    console.log(IDs);\n    const recipe = await getRecipe(IDs[2]);\n    console.log(recipe);\n    const related = await getRelated('Jonas Schmedtmann');\n    console.log(related);\n\n    return recipe;\n}\n\ngetRecipesAW().then(result => console.log(`${result} is the best ever!`));\n```\n\n\n\n## Example weather API\n\n```js\nasync function getWeatherAW(woeid) {\ntry {\n    const result = await fetch(`https://crossorigin.me/https://www.metaweather.com/api/location/${woeid}/`);\n    const data = await result.json();\n    const tomorrow = data.consolidated_weather[1];\n    console.log(`Temperatures tomorrow in ${data.title} stay between ${tomorrow.min_temp} and ${tomorrow.max_temp}.`);\n    return data;\n} catch(error) {\n    alert(error);\n}\n}\n\ngetWeatherAW(2487956);\n\nlet dataLondon;\ngetWeatherAW(44418).then(data => {\ndataLondon = data\nconsole.log(dataLondon);\n});\n```","tags":[],"folderPathname":"/","data":{},"createdAt":"2020-10-17T14:51:53.841Z","updatedAt":"2020-10-17T15:04:30.753Z","trashed":false,"_rev":"zz-u7UNKA"}